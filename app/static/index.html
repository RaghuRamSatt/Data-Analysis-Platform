<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Multidimensional Data Analysis</title>
    <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Roboto', sans-serif;
            line-height: 1.6;
            color: #333;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f4f4f4;
        }
        h1 {
            text-align: center;
            color: #2c3e50;
        }
        .container {
            background-color: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 0 10px rgba(0,0,0,0.1);
        }
        .input-section {
            display: flex;
            justify-content: center;
            align-items: center;
            margin-bottom: 20px;
        }
        #fileInput {
            display: none;
        }
        .file-label {
            padding: 10px 15px;
            background-color: #3498db;
            color: white;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.3s;
        }
        .file-label:hover {
            background-color: #2980b9;
        }
        #processButton {
            padding: 10px 15px;
            background-color: #2ecc71;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.3s;
            margin-left: 10px;
        }
        #processButton:hover {
            background-color: #27ae60;
        }
        #fileName {
            margin-left: 10px;
        }
        .plot-container {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
            gap: 20px;
            margin-top: 20px;
        }
        .plot {
            background-color: white;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 0 5px rgba(0,0,0,0.1);
        }
        #loadingIndicator {
            display: none;
            text-align: center;
            margin-top: 20px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Multidimensional Data Analysis</h1>
        <div class="input-section">
            <label for="fileInput" class="file-label">Choose CSV File</label>
            <input type="file" id="fileInput" accept=".csv">
            <span id="fileName"></span>
            <button id="processButton" onclick="processData()" disabled>Process Data</button>
        </div>
        <div id="loadingIndicator">Processing data, please wait...</div>
        <div class="controls">
            <select id="plot-type">
                <option value="2d">2D Plot</option>
                <option value="3d">3D Plot</option>
            </select>
            <select id="x-axis"></select>
            <select id="y-axis"></select>
            <select id="z-axis" style="display: none;"></select>
            <button onclick="updatePlots()">Update Plots</button>
        </div>
        <div class="plot-container">
            <div id="original-plot" class="plot"></div>
            <div id="pca-plot" class="plot"></div>
            <div id="tsne-plot" class="plot"></div>
            <div id="kmeans-plot" class="plot"></div>
            <div id="dbscan-plot" class="plot"></div>
        </div>
    </div>
    
    <script>
        const fileInput = document.getElementById('fileInput');
        const fileName = document.getElementById('fileName');
        const processButton = document.getElementById('processButton');
        const loadingIndicator = document.getElementById('loadingIndicator');

        fileInput.addEventListener('change', (event) => {
            const file = event.target.files[0];
            if (file) {
                fileName.textContent = file.name;
                processButton.disabled = false;
            } else {
                fileName.textContent = '';
                processButton.disabled = true;
            }
        });

        async function processData() {
            const file = fileInput.files[0];
            if (!file) {
                alert('Please select a CSV file');
                return;
            }
            
            console.log('Starting data processing...');
            loadingIndicator.style.display = 'block';
            processButton.disabled = true;
            
            try {
                console.log('Reading CSV...');
                const data = await readCSV(file);
                console.log('CSV read complete. Sending data to server...');
                const response = await fetch('/api/process', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({ data }),
                });
                
                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(errorData.error || 'Unknown error occurred');
                }
                
                console.log('Server processing complete. Rendering plots...');
                const result = await response.json();
                globalResult = result;
                populateAxisSelectors(result.feature_names);
                plotResults(result);
                console.log('Plotting complete.');
            } catch (error) {
                console.error('Error processing data:', error);
                alert(`An error occurred while processing the data: ${error.message}`);
            } finally {
                loadingIndicator.style.display = 'none';
                processButton.disabled = false;
            }
        }

        async function readCSV(file) {
            return new Promise((resolve) => {
                const reader = new FileReader();
                reader.onload = (e) => {
                    const text = e.target.result;
                    const lines = text.split('\n').filter(line => line.trim() !== '');
                    const headers = lines[0].split(',').map(header => header.trim());
                    console.log('Headers:', headers);
                    const data = lines.slice(1).map((line, lineIndex) => {
                        const values = line.split(',');
                        if (values.length !== headers.length) {
                            console.warn(`Line ${lineIndex + 2} has ${values.length} values, expected ${headers.length}`);
                        }
                        return headers.reduce((obj, header, index) => {
                            const value = index < values.length ? values[index].trim() : '';
                            obj[header] = value === '' ? null : isNaN(value) ? value : parseFloat(value);
                            return obj;
                        }, {});
                    });
                    console.log('Parsed data (first 5 rows):', data.slice(0, 5));
                    resolve(data);
                };
                reader.readAsText(file);
            });
        }

        function populateAxisSelectors(features) {
            const selectors = ['x-axis', 'y-axis', 'z-axis'];
            selectors.forEach((selector, index) => {
                const select = document.getElementById(selector);
                select.innerHTML = '';
                features.forEach((feature, i) => {
                    const option = document.createElement('option');
                    option.value = i;
                    option.text = feature;
                    select.appendChild(option);
                });
                select.selectedIndex = index;
            });
        }

        document.getElementById('plot-type').addEventListener('change', function() {
            document.getElementById('z-axis').style.display = 
                this.value === '3d' ? 'inline-block' : 'none';
        });

        function updatePlots() {
            if (globalResult) {
                plotResults(globalResult);
            }
        }

        function plotResults(result) {
            const plotType = document.getElementById('plot-type').value;
            const xIndex = document.getElementById('x-axis').value;
            const yIndex = document.getElementById('y-axis').value;
            const zIndex = document.getElementById('z-axis').value;

            const xLabel = result.feature_names[xIndex];
            const yLabel = result.feature_names[yIndex];
            const zLabel = plotType === '3d' ? result.feature_names[zIndex] : null;

            plotScatter('original-plot', result.original_data, 'Original Data', xLabel, yLabel, zLabel);
            plotScatter('pca-plot', result.pca, 'PCA Results', 'PC1', 'PC2', plotType === '3d' ? 'PC3' : null);
            plotScatter('tsne-plot', result.tsne, 't-SNE Results', 't-SNE 1', 't-SNE 2', plotType === '3d' ? 't-SNE 3' : null);
            plotScatter('kmeans-plot', result.original_data, 'K-means Clustering', xLabel, yLabel, zLabel, result.kmeans_labels);
            plotScatter('dbscan-plot', result.original_data, 'DBSCAN Clustering', xLabel, yLabel, zLabel, result.dbscan_labels);
        }

        function plotScatter(elementId, data, title, xLabel, yLabel, zLabel, colors) {
            const trace = {
                x: data.map(p => p[0]),
                y: data.map(p => p[1]),
                mode: 'markers',
                type: 'scatter',
                marker: colors ? { color: colors, colorscale: 'Viridis' } : {},
            };

            if (zLabel) {
                trace.z = data.map(p => p[2]);
                trace.type = 'scatter3d';
            }

            const layout = {
                title: title,
                xaxis: { title: xLabel },
                yaxis: { title: yLabel },
                height: 400,
                margin: { l: 50, r: 50, b: 50, t: 50, pad: 4 }
            };

            if (zLabel) {
                layout.scene = {
                    xaxis: { title: xLabel },
                    yaxis: { title: yLabel },
                    zaxis: { title: zLabel }
                };
            }

            Plotly.newPlot(elementId, [trace], layout);

            let explanation = '';
            switch(elementId) {
                case 'pca-plot':
                    explanation = 'PCA reduces the dimensionality of the data while preserving as much variance as possible. Each point represents an Iris flower, and their positions show how they relate to each other based on the two most important combined features.';
                    break;
                case 'tsne-plot':
                    explanation = 't-SNE is a technique for dimensionality reduction that is particularly good at preserving local structures in the data. It helps visualize high-dimensional data by giving each datapoint a location in a two-dimensional map.';
                    break;
                case 'kmeans-plot':
                    explanation = 'K-means clustering groups similar data points together. Each color represents a different cluster, showing how the algorithm has grouped the Iris flowers based on their features.';
                    break;
                case 'dbscan-plot':
                    explanation = 'DBSCAN clustering groups data points that are closely packed together, separating clusters of high density from areas of low density. Each color represents a different cluster, with possible noise points in a distinct color.';
                    break;
            }
            
            const explanationDiv = document.createElement('div');
            explanationDiv.innerHTML = explanation;
            explanationDiv.style.marginTop = '10px';
            explanationDiv.style.fontSize = '14px';
            explanationDiv.style.color = '#666';
            document.getElementById(elementId).appendChild(explanationDiv);
        }
        
    </script>
</body>
</html>